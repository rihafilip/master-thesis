%---------------------------------------------------------------
\chapter{Background}
%---------------------------------------------------------------

\begin{chapterabstract}
	\todoadd
\end{chapterabstract}

%---------------------------------------------------------------
\section{The R Language}
%---------------------------------------------------------------

\textit{R}\todocite is a programming language used for statistical computation and data visualization. It was developed Ross Ihaka and Robert Gentleman at the University of Auckland as an alternative to the S language\todocite. It is part of the GNU Project, licensed as a free software under GNU GPL.
\todo{expand}

The language is high-level, dynamic, object-oriented, functional, interpreted, and lazy, with automatic memory management.

The beauty of R is that very complex operations can be expressed in very few lines of code. \todo{some example} It is highly used by statistician, where a big part of them are non-programmers, and this is reflected in the design of the language.

The R syntax is very C-like, with \texttt{if} statements, \texttt{for} and \texttt{while} loops, array indexing and function calls. For assignment, the \texttt{<-} operator is used. Statements are separated by newline, optionally by semicolon if they are on the same line.

%---------------------------------------------------------------
\subsection*{Types}
%---------------------------------------------------------------

R basic types are the \textit{numeric types} (\textit{integer}, \textit{double} and \textit{complex}), \textit{character type} (strings) and \textit{logical type} (the boolean values \texttt{TRUE} and \texttt{FALSE}). R also has \texttt{NULL}, and a constant \texttt{NA} (\textit{not available}) representing a missing value.

R has no concept of scalars. Instead, all basic types are represented as \textit{vectors}. To create a vector with multiple elements, the function \texttt{c} (standing for combine) can be used. All the traditional mathematical operators are also vectorized.

For storing elements of different types, a \textit{list} is used. Other commonly used types built on top of vectors and lists are \textit{matrix} (two-dimensional vector), \textit{array} (multi-dimensional vector) and \textit{data frame} (matrix-like structure whose columns can have different types).

Every type can have associated \textit{attributes}, a collection of name-value pairs. These are accessed via the \texttt{attr} or \texttt{attributes} functions.

R also has multiple \textit{object models}. The most common ones are \textit{S3}, which is controlled by setting a \texttt{class} attribute on any type, and \textit{S4}, which defines more formal classes which have to be created and instantiated. S4 objects have special type.

%---------------------------------------------------------------
\subsection*{Environments}
%---------------------------------------------------------------

Different scopes in R are separated using objects named \textit{environments}. An environment consists of a \textit{frame}, which is the collection of variables, and a pointer to an \textit{enclosing environment} (also called a \textit{parent}). The topmost environment has a pointer to a special \textit{empty environment}, which has no other parent.

When a variable or a function is accessed, it is first looked for in the current environment. If not found, it is searched for recursively in each enclosing environment. Only then if it is not found, it is an error.

The lookup for functions is separate from non-function lookup. An assignment of a variable in some environment does not shadow a function in its enclosing environment. So the code \texttt{c <- 42; c(c, c)} results in one vector with two numbers 42, because the definition of the variable \texttt{c} does not shadow the function of the same name from the base environment.

These environments are also first-class values. We can create new environments (\texttt{new.env()}), access the value of the currently executed one (\texttt{environment()}), or even access and modify environments on the call stack (for example \texttt{sys.frame(-1)} accesses the environment of caller of current function).

%---------------------------------------------------------------
\subsection*{Functions}
%---------------------------------------------------------------

A \textit{function}, or also a \textit{closure}, is composed of three parts - \textit{formals}, which is the list of formal arguments and their default values, \textit{body}, which is the code of the function, and \textit{environment} defining the lexical scope of the function body. New functions can be created with the \texttt{function} keyword.

Most operations that happen in R are in fact function calls. This includes the control flow statements (like \textit{if} or \textit{while}), binary operations, assignment, and even surrounding an expression with parenthesis or multiple expression with braces. This is demonstrated in listing \ref{lst:r-special-calls}. Note that built-in functions have to be surrounded with backticks in order to referr to them as identifiers.

\begin{listing}
	\begin{minted}{R}
a <- if (TRUE) {
  1
} else
  2 * (3 + 4)

# This is equivalent to the previous statement
`<-`(a, `if`(
  TRUE,
  `{`(1),
  `*`(
    2,
    `(`(`+`(3, 4))
  )
))
  \end{minted}
	\caption{Demonstration of R special calls}\label{lst:r-special-calls}
\end{listing}

%---------------------------------------------------------------
\subsection*{Laziness}
%---------------------------------------------------------------

R is lazy in arguments. This means that when a function is called, the passed arguments are not instantly evaluated, but are instead wrapped in a \textit{promise}, a tuple of \textit{expression}, \textit{value}, and \textit{environment}. The value is at first set to the unbound value. When the promise is first accessed, the expression of the promise is evaluated with its environment (also called a \textit{force}). The result is cached in the value field, and every other access to the argument results in the cached value.

This can be seen in example \ref{lst:example-lazy}. The call at line 11 first prints \enquote{Hello} and only then the parameter \texttt{x} is accessed and the text \enquote{world} is printed. The second call to the function \texttt{h} demonstrates a second behavior - when a parameter is never accessed, it is not evaluated and thus the code of the promise is not executed and nothing is printed.

\begin{listing}
	\centering
	\begin{minted}{R}
f <- function(x) {
    print("world")
    x
}

g <- function(x) {
    print("Hello")
    x
}

g(f(42))

h <- function(x) 0

h(f(42))
  \end{minted}
	\caption{Example of R laziness}\label{lst:example-lazy}
\end{listing}

Promises can also be created manually by calling the \texttt{delayedAssign} function \todo{keep?}.

%---------------------------------------------------------------
\subsection*{Immutability}
%---------------------------------------------------------------

All R values are \textit{semantically immutable}, with the exception of environments. This means that when a variable holds a value, this value never changes unless the variable is reassigned. We say that non-environment values have a \textit{copy-on-modify behavior} - when a value is modified, a new copy is created with the modified parts. R employs an optimization in this regard - if there exists only one reference to a given value, we can modify it in place to reduce a redundant copy \todo{mention only in GNU-R?}.

Thanks to the syntax of R, it is possible to write code that looks like it is using mutability, but keeps the copy-on-modify behavior. In the example \ref{lst:imm}, the statement on line 3 looks like it is mutating the vector in place, but instead the function \texttt{[<-} is called, which creates a copy of the vector, modifies it and reassigns the variable x.

\begin{listing}
	\centering
	\begin{minted}{R}
x <- c(1, 2, 3)
y <- x
y[1] <- 42
# x is still vector (1, 2, 3)
  \end{minted}
	\caption{Immutability example}\label{lst:imm}
\end{listing}

The only truly mutable values are environments, and they conform to a \textit{reference behavior}. Listing \ref{lst:envir} shows this behavior - the variable \texttt{x} is added to both \texttt{e1} and \texttt{e1}, even though we only defined it on \texttt{e2}.

\begin{listing}
	\centering
	\begin{minted}{R}
e1 <- new.env()
e2 <- e1
e2$x <- 42
e1$x == 42
# TRUE
  \end{minted}
	\caption{Example of environment mutability}\label{lst:envir}
\end{listing}

%---------------------------------------------------------------
\subsection*{Reflection}
%---------------------------------------------------------------

\todo{}
As mentioned before, environments

\begin{listing}
	\centering
	\begin{minted}{R}
bad <- function() {
  rm("x", envir=sys.frame(-1)) # Remove the variable x from the caller
  2
}

good <- function(y) {
  x <- 1
  z <- y # Here is the promise is evalated
  x + z
}

good(bad())
# Error in good(bad()) : object 'x' not found
  \end{minted}
	\caption{Example of malicious reflection\todocite}\label{lst:bad-ref}
\end{listing}


% %---------------------------------------------------------------
% \chapter{The R Virtual Machine}
% %---------------------------------------------------------------
%
% \begin{chapterabstract}
% 	The R language is not formally specified, it only has a reference implementation that we will refer to as \textit{GNU-R}\todocite. On top of this virtual machine is built a Just-in-time compiler called \textit{Ř}\todocite. Although there are other implementations of R, we will only provide an overview on these two, as they are the focus of this thesis, and only provide an overview of the alternatives.
% \end{chapterabstract}

% \begin{listing}
% 	\begin{tabular}{p{0.48\textwidth} p{0.48\textwidth}}
% 		\begin{minted}[fontsize=\footnotesize,linenos=false]{text}
% -------------------------
% Code:
%   1 LDCONST 1
%   3 STARTFOR 4 3 27
%   7 GETFUN 5
%   9 MAKEPROM 7
%  11 CALL 6
%  13 BRIFNOT 8 22
%  16 GETVAR 9
%  18 SETVAR 9
%  20 GOTO 26
%  22 GETVAR 11
%  24 SETVAR 9
%  26 POP
%  27 STEPFOR 7
%  29 ENDFOR
%  30 POP
%  31 GETVAR 9
%  33 RETURN
% -------------------------
% Constant pool:
% 0:
%  language {  for (i in 1:10) {; if (g(..
% 1:
%  int [1:10] 1 2 3 4 5 6 7 8 9 10
% 2:
%  language 1:10
% 3:
%  symbol i
% 4:
%  language for (i in 1:10) {     if (g(..
% 5:
%  symbol g
% 6:
%  language g(x)
% 7:
%  Promise 0:
% -------------------------
% Code:
%   1 GETVAR 0
%   3 RETURN
% -------------------------
% Constant pool:
% 0:
%  symbol x
% 1:
%  language g(x)
% 2:
%  'expressionsIndex' int [1:4] NA 1 1 1
% -------------------------
%  End: Promise 0
% 8:
%  language if (g(x)) {     x <- x ...
% 9:
%  symbol x
% 10:
%  language x <- x
% 11:
%  symbol G
% 12:
%  language x <- G
% 13:
%  'expressionsIndex' int [1:34] NA 2 2 ..
% -------------------------
%     \end{minted}
% 		 &
% 		\begin{minted}[fontsize=\footnotesize,linenos=false]{text}
% 0:
%       0   push_  1
%       5   visible_
%       6   force_
%       7   push_  10
%      12   visible_
%      13   force_
%      14   ; :(1, 10)
%           colon_input_effects_
%      15   pop_
%      16   swap_
%      17   colon_cast_lhs_
%      18   [ <?> ] Type#0
%      23   ensure_named_
%      24   swap_
%      25   colon_cast_rhs_
%      26   ensure_named_
%      27   [ <?> ] Type#1
%      32   dup2_
%      33   ; NULL
%           le_
%      34   [ _ ] Test#0
%      39   brfalse_  1
%      44   push_  1L
%      49   br_  2
% 1:
%      54   push_  -1L
% 2:
%      59   swap_
%      60   pick_  2
%      65   dup2_
%      66   ; NULL
%           ne_
%      67   [ _ ] Test#1
%      72   brfalse_  7
%      77   dup_
%      78   stvar_cached_  i{0}
%      87   pull_  2
%      92   ensure_named_
%      93   ; NULL
%           add_
%      94   ldfun_  g
%      99   [ 0, <0>, valid  ] Call#0
%     104   mk_promise_  0
%     109   ; g(x)
%           call_  1
%     126   [ <?> ] Type#3
%     131   asbool_
%     132   brtrue_  3
%     137   ldvar_cached_  G{2}
%     146   [ <?> ] Type#4
%     151   stvar_cached_  x{1}
%     160   br_  4
% 3:
%     165   ldvar_cached_  x{1}
%     174   [ <?> ] Type#5
%     179   stvar_cached_  x{1}
% 4:
%     188   dup2_
%     189   ; NULL
%           ne_
%     190   brfalse_  7
%     195   dup_
%     196   stvar_cached_  i{0}
%     205   pull_  2
%     210   ensure_named_
%     211   ; NULL
%           add_
%     212   ldfun_  g
%     217   [ 0, <0>, valid  ] Call#1
%     222   mk_promise_  1
%     227   ; g(x)
%           call_  1
%     244   [ <?> ] Type#7
%     249   asbool_
%     250   brtrue_  5
%     255   ldvar_cached_  G{2}
%     264   [ <?> ] Type#8
%     269   stvar_cached_  x{1}
%     278   br_  6
% 5:
%     283   ldvar_cached_  x{1}
%     292   [ <?> ] Type#9
%     297   stvar_cached_  x{1}
% 6:
%     306   br_  4
% 7:
%     311   popn_  3
%     316   ldvar_cached_  x{1}
%     325   [ <?> ] Type#10
%     330   ret_
%
% [Prom (index 0)]
% 0:
%       0   ldvar_  x
%       5   [ <?> ] Type#2
%      10   ret_
%
% [Prom (index 1)]
% 0:
%       0   ldvar_  x
%       5   [ <?> ] Type#6
%      10   ret_
%
%     \end{minted}
% 	\end{tabular}
% \end{listing}

\newpage
%---------------------------------------------------------------
\section{GNU-R}
%---------------------------------------------------------------

\textit{GNU-R}, as the name suggest, is a part of the GNU project. It is written in the C programming language. \todo{expand}

\todo{what else?  bytecode compiler writen in R, interpreted in C}

%---------------------------------------------------------------
\subsection*{Representation}
%---------------------------------------------------------------

The GNU-R represents all code and values as \textit{symbolic expressions} (also \textit{S-expressions} or \textit{sexps}), a format for nested lists, popularized by the Lisp languages. The type \texttt{SEXP} is a pointer to either a \texttt{SEXPREC} or \texttt{VECTOR\_SEXPREC} structure. Both of these structures contain a header of type \texttt{sxpinfo\_struct}, a pointer to the attributes of the current value, and previous and next nodes in the garbage collector. The header then contains \texttt{SEXPTYPE}, the type of the \texttt{SEXP} (values are defined as in \ref{tbl:sexptype}), as well as additional attributes with information about the type, garbage collection and debug information. The rest of the structure cointains the actual data. The structure of a \texttt{SEXP} value is represented in figure \ref{fig:sexp-struct}.

\begin{figure}
	\centering
  \includediagram{0}
  \caption{Structure of the GNU-R \texttt{SEXP} type}\label{fig:sexp-struct}
\end{figure}

\begin{table}[h!]
	\begin{tabular}{c l l}
		\textbf{no} & \textbf{SEXPTYPE} & \textbf{Description}       \\
		\hline
		0           & NILSXP            & NULL                       \\
		1           & SYMSXP            & symbols                    \\
		2           & LISTSXP           & pairlists                  \\
		3           & CLOSXP            & closures                   \\
		4           & ENVSXP            & environments               \\
		5           & PROMSXP           & promises                   \\
		6           & LANGSXP           & language objects           \\
		7           & SPECIALSXP        & special functions          \\
		8           & BUILTINSXP        & builtin functions          \\
		9           & CHARSXP           & internal character strings \\
		10          & LGLSXP            & logical vectors            \\
		13          & INTSXP            & integer vectors            \\
		14          & REALSXP           & numeric vectors            \\
		15          & CPLXSXP           & complex vectors            \\
		16          & STRSXP            & character vectors          \\
		17          & DOTSXP            & dot-dot-dot object         \\
		18          & ANYSXP            & make “any” args work       \\
		19          & VECSXP            & list (generic vector)      \\
		20          & EXPRSXP           & expression vector          \\
		21          & BCODESXP          & byte code                  \\
		22          & EXTPTRSXP         & external pointer           \\
		23          & WEAKREFSXP        & weak reference             \\
		24          & RAWSXP            & raw vector                 \\
		25          & OBJSXP            & objects not of simple type \\
	\end{tabular}
	\caption{The different SEXP types\cite[1.1.1 SEXPTYPEs]{rprojectInternals}}\label{tbl:sexptype}
\end{table}

These structures are not available directly, the \texttt{SEXP} is exported as an opaque pointer type. Individual fields are accessible via exported functions.

%---------------------------------------------------------------
\subsection*{Interpreter}
%---------------------------------------------------------------

The GNU-R parses the code to an \textit{abstract syntaxt tree} (\textit{AST}), also represented with \texttt{SEXP}s with the \texttt{LANGSXP} type.

After the first execution of a function or by calling \texttt{compiler::cmpfun} on it, the function is passed to a \textit{bytecode compiler}, written in R and is a part of the GNU-R. The bytecode is stack-based with complex instructions, like special instructions for \texttt{for} loops, or \todo{...}.

When a function is compiled, its \texttt{SEXP} is modified in-place, replacing the AST body with a bytecode. Every other call to this function is then interpreted by the bytecode interpreter, which is written in C and is also is part of the GNU-R.

%---------------------------------------------------------------
\subsection*{Garbage Collector}
%---------------------------------------------------------------
R does not have primitives for managing memory, instead an automatic memory management provided by the runtime is expected. GNU-R uses a generational non-moving stop-the-world garbage collector with three generations\todocite.

In order to correctly match the generation of objects assigned to other object, it uses a \textit{write barrier}\todocite. This is always managed by the interal functions, and since the internals of \texttt{SEXP} are not exported, it is always correct \todo{reword}.

Next to the GC, GNU-R also has a reference counter for each object, included in the object header, with values 0, 1 and many. This is used for optimistic mutations - when an object would be copied and mutated, but there is only one reference to it, it is instead mutated in place, avoiding an unnecesarry copy. This correctly preserves the copy-on-modify behavior.

%---------------------------------------------------------------
\section{The Ř compiler}
%---------------------------------------------------------------

\textit{Ř} (also stylized as \textit{Rsh}) is a just-in-time compiler for the R language, developed at Programming Languages Laboratory at Czech Technical University in Prague\todocite and Programming Research Laboratory at Notheastern University\todocite. The project is freely available and hosted on GitHub.

It is built as an extension to GNU-R, although several changes need to be made to the original codebase in order to use it. It bypasses the GNU-R bytecode compiler and interpreter, instead using a custom one, while reusing the \texttt{SEXP} representation, AST interpreter, and garbage collector.

For the compilation to native code, the \textit{LLVM Project}\todocite is used.

\todo{picture, high-level overview of Ř}

%---------------------------------------------------------------
\subsection{Runtime objects}
%---------------------------------------------------------------

Ř uses the GNU-R \texttt{SEXP} representation and memory management. All runtime objects are embedded into the SEXP objects. This is one of the modifications that need to be applied to GNU-R, a new \texttt{SEXPTYPE} is added (\texttt{EXTERNALSXP}), along with the necessary changes to how it is collected and how it references other objects.

The structure of Ř runtime object can be seen in figure \ref{fig:rsh-object-struct}. It represented as the \texttt{SEXP} header, the \texttt{SEXPTYPE} alwyas set to the \texttt{EXTERNALSXP}, and then the embeded \texttt{RirRuntimeObject}. This object always starts with two \texttt{uint32\_t} numbers, the first dictates how many bytes after the start of the Ř object do start the pointers to the other \texttt{SEXP}s, and the second indicates how many pointers are there. The magic number dictates which Ř object it is.

There are helpers macros to access the headers, as well as the pointers to other \texttt{SEXP}s. On the Ř side, there are functions to convert between a C++ pointer and a SEXP.

\begin{figure}
	\centering
  \includediagram{1}
  \caption{Structure of the Ř runtime objects}\label{fig:rsh-object-struct}
\end{figure}

\begin{figure}
	\centering
  \includediagram[0.7]{2}
  \caption{Runtime representation of Ř Type Feedback}\label{fig:rsh-tf-struct}
\end{figure}

%---------------------------------------------------------------
\subsection{RIR bytecode interpreter}
%---------------------------------------------------------------

The bytecode used by Ř is called \textit{RIR}. It is a stack-based bytecode, interpreted by a Ř interpreter. It uses the GNU-R bytecode execution stack.

When a function is compiled to \texttt{RIR}, its body gets replaced with a \textit{dispatch table}.

\todo{how is a loop hijacked}

For this thesis, the important bytecode instructions are \texttt{record\_call\_}, \texttt{record\_type\_}, and \texttt{record\_test\_}. These are executed after a \textit{callee load}, \textit{variable load} or a \textit{branch condition evaluation} respectively. The semantics of the instructions is observing the top value on the stack\todo{which stack} and record the information to the  \texttt{TypeFeedback} structure. The name \texttt{TypeFeedback} is a bit misleading here - it observes the type of value only for \texttt{record\_type\_}, whereas the \texttt{record\_call\_} records the address of callee, and \texttt{record\_test\_} if the top value is true, false, or any other.

Apart from the runtime values, the RIR interpreter also records other informations about the running program, most notably the number of times a function has been invoked, and the number of times a loop has been executed. These are used to determine which parts of the program are executed frequently, and thus are a good candidates for compiling to native code.

%---------------------------------------------------------------
\subsection{PIR compiler}
%---------------------------------------------------------------
When a function or a loop is determined to be hot, it is compiled to \textit{PIR}, an intermediate representation used for the compilation to native code.

PIR is composed of instruciton in a \textit{static single-assignment form} (\textit{SSA}). This means that all variables (called \textit{registers}) can be assigned only once, and they have to be assigned first before their first usage.

PIR instructions are organized in \textit{basic blocks}, a continuous block of instruction ending in a \textit{terminator instruciton} - a (conditional) jump to another basic block, or a speculation anchor (explained later, see \todo{add chapter}).

These basic blocks then form a \textit{directed graph}, which is encapsulated in a \textit{function}.

After all of the optimizations are finished, the PIR code is transformed into \textit{LLVM bitcode}, the intermediate representation of LLVM. This is then passed to the \textit{ORC JIT compiler}, which is part of the LLVM project and which does the lowering itself.

%---------------------------------------------------------------
\subsection{Contextual dispatch}
%---------------------------------------------------------------

% %---------------------------------------------------------------
% \section{Other Implementations}
% %---------------------------------------------------------------
%
% \todo{\\ pqR \\ FastR \\ Renjin \\ rho \\ Riposte \\ Microsoft R Open \\ GraalVM R}
