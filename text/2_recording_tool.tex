%---------------------------------------------------------------
\chapter{Recording Tool}
%---------------------------------------------------------------

\begin{chapterabstract}
	\todoadd
\end{chapterabstract}

\todo{demo}

%---------------------------------------------------------------
\section{Motivation}
%---------------------------------------------------------------

The problem we observed was that the behavior of Ř is a black box. There are logging utilities for the JIT compilation, but these only print the RIR, PIR and LLVM code at the different stages of compilation. This is usefull for manual observation of the produced code, or for tracking down bugs in the compilation, but it does not reflect the rest of Ř.

What we want is an event log that would reflect the behaviour of the compiler, like in the figure \todoadd. We want to have information about what functions were invoked and to which version was the call dispatched. When a functions is compiled, we do not know what was the reason for the compilation, as there are multiple heuristics used. When a deoptimization happens, we can log the final PIR instruction than triggered the deoptimization, but not the runtime value that caused it.

In reality, the behavior is more complex than the motivating figure. When a compilation is triggered (we call that a start of \textit{compilation session}), multiple closures can be lowered to their native version. At the time of compilation, the feedback vector of each function is static, but we have no idea of how we got to that state, thus we also have observe all changes to of the feedback during the execution. In the end, the event log look more like in figure \todoadd.

%---------------------------------------------------------------
\section{Design}
%---------------------------------------------------------------

One of the most important things about designing the recording tool was to minimize the intrusiveness as much as possible, as observing the events is a matter of debugging, not a release build. Thus we do not modify any function signatures, nor structure fields and the recording tool has to be explicitly turned on when compiling Ř. When it is not enabled, it has basically zero impact on the codebase.

Another design goal was to not clutter the code of the compiler. Observing events is a cross-cutting concern impacting the whole codebase, similarly to logging. We do not want to have to keep around a state connected to the recording in the compiler, because this would increase the complexity a lot.

What we ended up with is a series of \textit{hooks} that are used by the rest of the codebase. These hooks collect information in global state, but this is hidden from the caller. Since both the R and Ř code is sequential, we do not need to deal with any concurrency issues, but we still have to be careful with managing the global state. One feature that we leverage is that the C++ code is compiled without any exceptions, thus we can reliably use cleanup calls with confidence about the control flow of the program.

As an example, in the listing \ref{lst:hook-docall} in the function \texttt{doCall} we can see the logic around passing a function to the compiler when certain heuristics and conditions are met. \texttt{RecompileHeuristic} and \texttt{RecompileCondition} are pure functions, each having multiple heuristics or conditions respectively, but the information about which was triggered is lost. Therefore when a condition or heuristic is met, we call to a hook that captures the information in the global state (also illustrated in \ref{lst:hook-docall}, in the funciton \texttt{RecompileCondition}). If a compilation happens, we leverage this information from the global state with another hook. If a compilation does not happen, we reset the global state with the \texttt{recording::recordReasonsClear} hook.

This architecture of global state allowed us to make minimal changes to the code base while still collecting important information during various stages of the compiler.

\begin{listing}
	\centering
	\begin{minted}{cpp}
SEXP doCall(/* arg */) {
  // ...
  if (!isDeoptimizing() && RecompileHeuristic(/* args */)) {
      if (RecompileCondition(/* args */)) {
          if (/* OSR condition */) {
              REC_HOOK(recording::recordOsrTriggerCallerCallee());
              call.triggerOsr = true;
          }
          DoRecompile(/* args */);
      }
  }
  REC_HOOK(recording::recordReasonsClear());
  // ...
}

bool RecompileCondition(/* args */) {
    if (fun->flags.contains(Function::MarkOpt)) {
        REC_HOOK(recording::recordMarkOptReasonCondition());
        return true;
    }

    if (!fun->isOptimized()) {
        REC_HOOK(recording::recordNotOptimizedReason());
        return true;
    }

    // ... Other conditions

    return false;
}
  \end{minted}
	\caption{Simplified code of compilation logic in interpreter/interp.cpp}\label{lst:hook-docall}
\end{listing}

Lastly, the result of the recording tool is meant for further analysis, both by hand and programatically. \todoadd

\todo{mention potentional replaying?}

%---------------------------------------------------------------
\section{Implementation}
%---------------------------------------------------------------

The code is merged into the main branch of Ř and it is available on GitHub \todoadd. All the implementation is in the folder \texttt{rir/src} in files \texttt{recording.\{h, cpp\}}, \texttt{recording\_hooks.\{h, cpp\}} and \texttt{recording\_serialization.h}, under the namespace \texttt{rir::recording}.

%---------------------------------------------------------------
\subsection{Hooks}
%---------------------------------------------------------------

All of the hook functions are defined in the file \texttt{recording\_serialization.h}. This is the only file intended to be included by other parts of the compiler. Calling a hook either emits an event or adds information to the global state to be used by other hooks.

All calls to the hooks are surrounded by the \texttt{REC\_HOOK} macro. This macro controls the conditional compilation of these hooks, where if the recording is not enabled, the macro results in nothing \todo{add REC\_HOOK definiton?}.

The only instances where a recording state is managed by the hook caller is when capturing if a feedback recording changed the feedback, seen for example in the \texttt{ObservedTest} in listing \ref{lst:hook-observedtest}. But these are only small pieces of code, \todoadd. All other instances of state are managed by the hooks.

\begin{listing}
	\centering
	\begin{minted}{cpp}
void record(const SEXP e) {
    REC_HOOK(uint32_t old = seen);
    // Logic for modifying the `seen` member
    REC_HOOK(recording::recordSCChanged(old != seen));
}
  \end{minted}
	\caption{Example of recording state management in a hook caller in the class \texttt{ObservedTest} in file runtime/TypeFeedback.h}\label{lst:hook-observedtest}
\end{listing}

%---------------------------------------------------------------
\subsection{Recorder}
%---------------------------------------------------------------

The main orchestration is performed in the class \texttt{Record}, as defined in the listing \ref{lst:record-class}. This class contains the observed events and closures they belong to.

\begin{listing}
	\begin{minted}{cpp}
class Record {
    std::unordered_map<const DispatchTable*, size_t> dt_to_recording_index_;
    std::unordered_map<int, size_t> primitive_to_body_index;
    std::unordered_map<SEXP, size_t> bcode_to_body_index;
    std::unordered_map<Function*, size_t> expr_to_body_index;

  public:
    std::vector<FunRecording> functions;
    std::vector<std::unique_ptr<Event>> log;

    template <typename E, typename... Args>
    void record(SEXP cls, Args&&... args);

    template <typename E, typename... Args>
    void record(const DispatchTable* dt, Args&&... args);

    template <typename E, typename... Args>
    void record(Function* fun, Args&&... args);
};

struct FunRecording {
    // Index into the array of primitive functions, or -1
    ssize_t primIdx = -1;
    // Possibly empty name of the closure
    std::string name;
    // Possibly empty name of the environment
    // in which the name was bound to the closure
    std::string env;
    // The serialized closure
    SEXP closure = R_NilValue;
    // The address of the closure
    uintptr_t address = 0;
};
  \end{minted}
	\caption{Simplified definition of \texttt{Record} and \texttt{FunRecording} classes \todo{remove the record methods?}}\label{lst:record-class}
\end{listing}

We say that each event is connected to some closure, either a Ř dispatch table, Ř function without a dispatch table (when it is a top-level compilation), a GNU-R compiled code (represented by some SEXP), or a primitive function. When we first observe a closure, we create an associated \texttt{FunRecording} in the field \texttt{functions}. We try to find a name of the closure and the name of its environment for the given closure and serialize the closure (serialization can be disabled). Every other time we observe an event connected with the same closure, we reuse the \texttt{FunRecording}. This is what the \texttt{*\_to\_recoding\_index} fields are used for. Events hold a single index into the \texttt{functions} field.

We use thoroughly that the GNU-R garbage collector is non-moving, as we can then index by the address of the objects and we can be sure that they are valid. There is still a possibility that an object whose address we have captured gets collected and in its place a new object will be placed. This is prevented by calling the \texttt{R\_PreserveObject} function exported from GNU-R. This adds the object to a \textit{precious list} so that the garbage collector never collects it until it is removed from the list by calling \texttt{R\_ReleaseObject}. A drawback of this approch is the possibility of different runtime properties of some programs, but we have not observed any observable difference.

%---------------------------------------------------------------
\subsection{Events}
%---------------------------------------------------------------

An \texttt{Event} is an abstract class from which all other events inherit. Every event has an index of a \texttt{FunRecording} to which it is connected.

Currently, there are eight different events.

\textit{Compilation start} and \textit{compilation end} events denote the start and end of a \textit{compilation session}, a single call to the compiler during which multiple closures might be lowered to native code. These events act as brackets of sorts, everything in between these is connected to the one compilation session. They record the heuristics used for triggering the compilation, its duration, and if it at any point failed. For each of the closures we then register a \textit{compilation event}, where we reference the closure that was compiled, the type feedback it used, the PIR code that it resulted in, the LLVM bitcode to which it was lowered, and the number of \texttt{Deopt} instrucitons.

When a deoptimization occurs, the \textit{deopt event} is triggered. It captures the deopt reason, the function and its feedback slot it is connected with, and also the trigger, which is a closure referenced as \texttt{FunRecoding}, or the \texttt{SEXP} value.

Every time we invoke a function, we register an \textit{invoke event}. Due to contextual dispatch, there are multiple places where a call might be dispatched. Thus, we capture the \textit{call context}, the infered context of the arguments, and if we are dispatching to a natively compiled function \todo{missing asmpt present, recovered}. There are also different places where the dispatching is resolved; this is captured in the source field.

Due to the architecture of Ř, we also have a \textit{unregister invocation event}. \todoadd

An update of the type feedback is registered as \textit{speculative context event}. We capture which feedback slot was modified, what is the new infomation in it, if the information is changed, and if the change has happend because of a deoptimization.

We also have a definition of a \textit{custom event}, which is a user-defined message that can be emitted with the R api.

%---------------------------------------------------------------
\subsection{Interface}
%---------------------------------------------------------------

Currently, there are two ways to interact with the recording - environment variables passed to the program, and exported R functions.

%---------------------------------------------------------------
\subsubsection*{Environment Variables}
%---------------------------------------------------------------

With the environment variables, it is possible to record the whole run of a program. This is done by setting \texttt{RIR\_RECORD} to the path where the serialized recording should be stored. With the \texttt{RIR\_RECORD\_FILTER} variable, we can control which events should be considered, while ignoring the rest. The available values are \texttt{Compile}, \texttt{Deopt}, \texttt{TypeFeedback} and \texttt{Invoke} and multiple can be specified when separated by a comma. Custom events cannot be filtered out.

As an example, by calling

\mintoneline{bash}{RIR_RECORD=output.rds RIR_RECORD_FILTER=Compile,TypeFeedback R -f test.R}

\noindent we record all compilation and type feedback events that were generated while running the script \texttt{test.R} into the file \texttt{output.rds}.

There is also a \texttt{RIR\_RECORD\_SERIALIZE} environment variable which if it is set to nonzero integer enables the serialization of closures and deopt events. Serialization is turned off by default due to a bug in the serialization of Ř objects \todo{say somewhere else}.

%---------------------------------------------------------------
\subsubsection*{R API}
%---------------------------------------------------------------

The functions available in R are: \todo{cite the GitHub documentation?}

\begin{itemize}
	\item \texttt{recordings.start()} starts or resumes the recording,
	\item \texttt{recordings.stop()} pauses the recording,
	\item \texttt{recordings.get()} returns the object with recorded functions and events,

	\item \texttt{recordings.save(filename)} saves the recording as an RDS to the given file,
	\item \texttt{recordings.load(filename)} loads the recording from the given file and returns the object representing it,

	\item \texttt{recordings.reset()} clears all of the recording informations,
	\item \texttt{recordings.enabled()} returns a boolean representing if we are recording right now,

	\item \texttt{recordings.setFilter(compile, deoptimize, type\_feedback, invocation)} sets the filtering of individual events,

	\item and \texttt{recordings.customEvent(message)} creates a custom event with the associated message.
	\item \todo{eval, printEventPart}
\end{itemize}

%---------------------------------------------------------------
\subsection{Serialization}
%---------------------------------------------------------------

In order to analyze the recorded data

%---------------------------------------------------------------
\subsubsection*{CSV Format}
%---------------------------------------------------------------

%---------------------------------------------------------------
\section{Assesment}
%---------------------------------------------------------------

